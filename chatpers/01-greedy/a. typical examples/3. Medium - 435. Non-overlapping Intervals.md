# 435. Non-overlapping Intervals  
**Tags:** Greedy, Sorting, Intervals  

---

## Problem Description  

Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`,  
return the **minimum number of intervals** you need to remove to make the rest of the intervals non-overlapping.  

Note:  
Intervals that only touch at a single point are considered **non-overlapping**.  
For example, `[1,2]` and `[2,3]` do **not** overlap.

---

## 中文题意  

给定若干闭区间 `intervals[i] = [start_i, end_i]`，  
请计算**最少需要移除多少个区间**，  
使得剩下的区间互不重叠（两个区间端点相接视为不重叠）。  

---

## Example 1  

**Input:**  
`intervals = [[1,2],[2,3],[3,4],[1,3]]`  
**Output:**  
`1`  

**Explanation:**  
Remove `[1,3]`, and the rest are non-overlapping: `[1,2], [2,3], [3,4]`.

---

## Example 2  

**Input:**  
`intervals = [[1,2],[1,2],[1,2]]`  
**Output:**  
`2`  

**Explanation:**  
We need to remove two `[1,2]` intervals to make the rest non-overlapping.

---

## Example 3  

**Input:**  
`intervals = [[1,2],[2,3]]`  
**Output:**  
`0`  

**Explanation:**  
All intervals are already non-overlapping.

---

## Constraints  

- `1 <= intervals.length <= 10^5`  
- `intervals[i].length == 2`  
- `-5 * 10^4 <= start_i < end_i <= 5 * 10^4`

---

## Solution (Greedy — Sort by End Time)  

**Algorithm Idea:**  
This problem is a classic **Interval Scheduling Optimization**.  
To minimize removals, we can instead **maximize the number of non-overlapping intervals kept**.  

Steps:  
1. Sort intervals by their **end time** in ascending order.  
2. Initialize `prev_end` with the end of the first interval.  
3. Traverse all intervals:
   - If `start >= prev_end`, it means no overlap → **keep it**, update `prev_end = end`.  
   - Else, overlap occurs → **remove this interval** (since it ends later).  
4. Return the total number of removed intervals.  

This ensures the earliest finishing intervals are kept,  
leaving more space for future ones — a standard greedy argument for optimality.  

---

### Python Code  

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x:x[1])
        removed = 0
        prev_end = intervals[0][1] # Use the first interval's end as the initial selected end
        for i in range(1, len(intervals)):
            if prev_end > intervals[i][0]:
                removed += 1
            else:
                prev_end = intervals[i][1]
        return removed
```
## Sorting by Interval End — Summary / 按区间结束位置排序的总结

Key Line / 关键语句：

    intervals.sort(key=lambda x: x[1])

Explanation (English):
- This line sorts all intervals by their end position in ascending order.
- An interval with an earlier end leaves more room for the next interval.
- This helps the greedy strategy keep the maximum number of non-overlapping intervals.
- Sorting by x[1] means we sort by each interval’s ending point.

In short:
Sort intervals by their ending positions so the greedy algorithm always picks the earliest-finishing interval.

解释：
- 这一行代码将所有区间按照结束位置（end）从小到大排序。
- 结束越早的区间，对后续区间越友好，留下更多空间。
- 这样贪心算法就能保留更多不重叠的区间。
- x[1] 表示每个区间的结束位置，因此按它排序。

