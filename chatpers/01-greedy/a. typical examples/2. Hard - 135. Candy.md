
# 135. Candy  
**Tags:** Greedy, Two-pass, Array  

---

## Problem Description  

There are `n` children standing in a line.  
Each child is assigned a rating value given in the integer array `ratings`.

You are giving candies to these children subjected to the following requirements:

- Each child must have **at least one candy**.  
- Children with a **higher rating** get **more candies** than their neighbors.

Return the *minimum number of candies* you need to have to distribute the candies to the children.

---

## 中文题意  

有 `n` 个孩子站成一排，每个孩子都有一个评分。  
你需要分发糖果，要求如下：  
1. 每个孩子至少得到 **1 颗糖**；  
2. 评分更高的孩子比相邻的孩子得到 **更多的糖**。  

求分发糖果的最少总数量。

---

## Example 1  

**Input:**  
`ratings = [1,0,2]`  

**Output:**  
`5`  

**Explanation:**  
You can allocate candies as `[2,1,2]`.  
The middle child gets the least candy, while the others get more.  
Total = `2 + 1 + 2 = 5`.

---

## Example 2  

**Input:**  
`ratings = [1,2,2]`  

**Output:**  
`4`  

**Explanation:**  
You can allocate candies as `[1,2,1]`.  
The third child has the same rating as the second, so no extra candy is needed.  
Total = `1 + 2 + 1 = 4`.

---

## Constraints  

- `n == ratings.length`  
- `1 <= n <= 2 * 10^4`  
- `0 <= ratings[i] <= 2 * 10^4`

---

## Solution — Greedy algorithm + bidirectional traversal (Recommended & Most Readable， O(n))

**Idea.**  
Satisfy left-neighbor constraints in a left→right pass, then satisfy right-neighbor constraints in a right→left pass.  
For each child `i`, the final number of candies is the **maximum** required by both directions.  
This ensures every rule is met with the smallest total.

**为什么可行（思路证明）：**  
- 左向扫描：保证每个上坡孩子（评分比左边高）得到更多糖果；  
- 右向扫描：保证每个下坡孩子（评分比右边高）得到更多糖果；  
- 对每个孩子取两方向要求的最大值，就能在同时满足两边的前提下保持最小总量。

---

### Python Code

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        n = len(ratings)
        candies = [1] * n  # give each child one candy, create a list
        # pass 1: left -> right
        for i in range(1, n):
            if ratings[i] > ratings[i - 1]:
                candies[i] = candies[i - 1] + 1
        # pass 2: right -> left
        for i in range(n - 1, 0, -1):
            if ratings[i - 1] > ratings[i]:
                candies[i - 1] = max(candies[i - 1], candies[i] + 1)
        return sum(candies)
```
---

## Initialization

We start by giving each child **one candy**, which is the minimum allowed:

```
candies = [1] * n
```

Why this works:

- `[1]` creates a one-element list containing the number `1`
- `* n` replicates it `n` times
- The result is a list of length `n`, where each child starts with exactly one candy

This provides a valid baseline.  
All later adjustments only **increase** candies to satisfy rating rules.

---

## Pass 1 — Left → Right

```
for i in range(1, n):
    if ratings[i] > ratings[i - 1]:
        candies[i] = candies[i - 1] + 1
```

Purpose:

- Handle the condition **“higher than left neighbor → must get more candies”**
- When scanning left→right, we already know the candy count of the left child, so this rule can be enforced greedily in one pass

Effect:

- All **increasing slopes** (like `1, 3, 4`) will be assigned strictly increasing candy values
- No other part is affected yet

---

## Pass 2 — Right → Left

```
for i in range(n - 1, 0, -1):
    if ratings[i - 1] > ratings[i]:
        candies[i - 1] = max(candies[i - 1], candies[i] + 1)
```

Purpose:

- Handle the condition **“higher than right neighbor → must get more candies”**
- Scanning right→left ensures that the right neighbor's candies have already been decided

Why `max` is necessary:

- The first pass may have already assigned a **larger** value to `candies[i - 1]`
- We are **not allowed** to decrease a candy count (that could break left-neighbor constraints)
- Therefore we take:

```
candies[i - 1] = max(candies[i - 1], candies[i] + 1)
```

This ensures:

- Both left- and right-neighbor rules are satisfied
- No correct assignment from the first pass is overwritten
- Candy counts only increase when necessary

---

## Correctness & Minimality

Because each direction enforces only the constraints it can safely verify, and because we take the **maximum** requirement from both passes:

- Every child satisfies both neighbor rules
- No child receives unnecessary extra candies
- The construction is greedy but provably minimal

This is the standard optimal solution for this problem.

---

## Time & Space Complexity

- **Time:** `O(n)`  
  Two linear passes over the array.

- **Space:** `O(n)`  
  Needed for the `candies` list.

Both are optimal for this problem.


