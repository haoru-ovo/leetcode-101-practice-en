# 1. Easy – 605. Can Place Flowers

**Tags:** Array, Greedy

---

## Problem Description (English)

You are given a long flowerbed represented by an integer array `flowerbed` where each element is either:

- `0` – this plot is empty, or  
- `1` – this plot already has a flower.

Two flowers are **not allowed** to be in adjacent plots, i.e. no two `1`s can be next to each other in the final arrangement.

You are also given an integer `n`, the number of new flowers you would like to plant.  
Return `true` if it is possible to plant `n` new flowers in the flowerbed without breaking the rule, and `false` otherwise.

---

## 中文题意（简要）

给定数组 `flowerbed`，元素只可能是 `0` 或 `1`：  
- `0` 表示空地；  
- `1` 表示已经种了花。  

规则：相邻的两个位置不能同时有花。  
再给一个整数 `n`，问能否在不违反规则的前提下，再种下至少 `n` 朵花，能则返回 `true`，否则返回 `false`。

---

## Examples

**Example 1**  

Input: `flowerbed = [1,0,0,0,1]`, `n = 1`  
Output: `true`  

**Example 2**  

Input: `flowerbed = [1,0,0,0,1]`, `n = 2`  
Output: `false`  

---

## Constraints

- `1 <= flowerbed.length <= 2 * 10^4`  
- `flowerbed[i]` is `0` or `1`.  
- There are no two adjacent `1`s in the initial flowerbed.  
- `0 <= n <= flowerbed.length`

---

## Python Code

```python
from typing import List

class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        length = len(flowerbed)
        planted = 0

        for i in range(length):
            if flowerbed[i] == 1:
                # This position already has a flower.
                continue

            # Check whether the left and right neighbors are empty (or out of bounds).
            empty_left = (i == 0) or (flowerbed[i - 1] == 0)
            empty_right = (i == length - 1) or (flowerbed[i + 1] == 0)

            if empty_left and empty_right:
                # Greedily plant a flower here.
                flowerbed[i] = 1
                planted += 1

        return planted >= n
```

---

## Solution Explanation (English)

The book places this problem in the *greedy* section and asks us to think about a local strategy that maximizes the total number of flowers.

We scan the array from left to right and make a greedy decision at each position:

1. For index `i`, we first require that the current plot is empty: `flowerbed[i] == 0`.
2. We then check both neighbors:
   - the left neighbor is empty or does not exist (`i == 0` or `flowerbed[i-1] == 0`);
   - the right neighbor is empty or does not exist (`i == length-1` or `flowerbed[i+1] == 0`).
3. If all three conditions hold, we plant a flower at `i` and mark `flowerbed[i] = 1`, so that later positions can see this newly planted flower.
4. We keep a counter of how many flowers we have planted. As soon as the counter reaches `n`, we can immediately return `true`.

This greedy strategy is optimal because planting a flower at a valid position only affects its two neighbors, which would be invalid for planting if we choose this position anyway. Skipping a valid position cannot give us more choices later, so “plant whenever it is safe” is safe and sufficient.

- Time complexity: `O(len(flowerbed))`  
- Space complexity: `O(1)` extra space

---

## 题解讲解（中文）

本题在书里属于“贪心”练习，核心是：**只要某个位置可以种花，就立刻种下去**。

具体做法是从左到右扫描数组，对每个位置 `i`：

1. 首先要求当前位置是空地：`flowerbed[i] == 0`。  
2. 然后检查左右两侧：  
   - 左边不存在，或者左边是空地：`i == 0` 或 `flowerbed[i-1] == 0`；  
   - 右边不存在，或者右边是空地：`i == length-1` 或 `flowerbed[i+1] == 0`。  
3. 如果以上三个条件都满足，就在这里种一朵花，把 `flowerbed[i]` 设成 `1`，并把计数 `planted` 加一。  
4. 每次种完之后判断一下，如果 `planted >= n`，说明已经成功种够了，可以直接返回 `true`。全部扫描完还达不到，就返回 `false`。

为什么“能种就种”的贪心不会吃亏？  
因为一旦我们选择在位置 `i` 种花，不管怎样，它的左右相邻两个格子都不能再种花；如果我们明明可以在这里种，却选择跳过，在更右边找位置，也不会凭空多出可用的位置。  
因此，这种局部最优选择（只要能种就种）可以保证整体也是最优的。

时间复杂度为 `O(n)`，空间复杂度为 `O(1)`。

---
