
# 5. Medium – 406. Queue Reconstruction by Height

**Tags:** Greedy, Sorting, Insertion

---

## Problem Description (English)

You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the ith person of height `hi` with exactly `ki` other people in front who have a height greater than or equal to `hi`.

Reconstruct and return the queue that is represented by the input array `people`. The returned queue should be formatted as an array queue, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).

---

## 中文题意（简要）

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 正好 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
---

## Examples

**Example 1**  

Input: `people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`  
Output: `[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]`  

**Example 2**  

Input: `people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]`  
Output: `[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]`  

---

## Constraints

- `1 <= people.length <= 2000`  
- `0 <= h <= 10^6`  
- `0 <= k < people.length`

---

## Python Code

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        # 1. Sort by h in descending order, k in ascending order
        people.sort(key=lambda x: (-x[0], x[1]))
        # 2. Insert into the corresponding positions one by one
        queue = []
        for p in people:
            queue.insert(p[1], p)
        return queue
```

---

## Solution Explanation (English)

The book hints that this problem requires both **sorting** and **insertion** operations, and the greedy insight is the key.

### 1. Sort by height (descending), then by k (ascending)

We first sort the array as follows:

1. Higher people come first (sort by `h` in **descending** order).  
2. Among people with the same height, smaller `k` comes first (sort by `k` in **ascending** order).

After this sorting, whenever we look at some person `[h, k]`, all people who are taller than `h` have already been placed, and people with the same height will be processed in order of increasing `k`.

### 2. Insert each person at index k

We start with an empty queue and process people in sorted order.  
For each person `[h, k]`, we insert them into the current queue at index `k`.  

Why does this work?

- Since we are processing from tallest to shortest, when we insert `[h, k]`, all people already in the queue are **not shorter** than `h`.  
- Inserting at position `k` ensures that exactly `k` people in front of them are of height `>= h`.  
- When we later insert shorter people, they do not affect the counts for taller people, because `k` only cares about people with height at least `h`.

Thus the greedy strategy of "tall first, insert at position `k`" constructs a queue satisfying all constraints.

---

## 题解讲解（中文）

书里对这道进阶题的提示是：**需要同时用到排序和插入操作**，核心贪心是：**先安排高个子，再安排矮个子**。

### 1. 按身高降序、k 升序排序

对数组 `people` 排序：

1. 身高 `h` 按 **降序** 排序，高个子排在前面；  
2. 如果身高相同，则按 `k` **升序** 排序。  

排序后，当我们处理某个人 `[h, k]` 时，所有比他高的人都已经处理完成，同身高的人会从小 `k` 到大 `k` 依次处理。

### 2. 依次插入到下标 k 的位置

从空队列 `queue` 开始，按排序后的顺序遍历每个人 `[h, k]`，直接把他插入到 `queue` 的下标 `k` 位置：

- 因为已经排好的都是身高 `>= h` 的人，插入到位置 `k`，就保证他前面正好有 `k` 个身高不低于他的人；  
- 之后插入更矮的人时，只会在他前后插入个子更矮的人，不会改变他前面“高个子”的数量。

因此，“**按身高降序排序 + 按 k 插入**”就是满足题目条件的贪心构造方法。


---
## 3. Why k must be sorted in ascending order（Why using only height descending is incorrect）
## 3. 为什么必须对 k 进行升序排序（仅按身高排序会导致错误）

A common question is:  
**“If we only sort by height descending, will the insertion strategy still work?”**  
The answer is **NO** — sorting by height alone will produce wrong queues.

许多人会问：  
**“如果只按身高降序排序，不管 k，会不会也构造出正确队列？”**  
答案是 **不会** —— 只按身高排序会导致插入顺序错误，生成非法队列。

### Counterexample（反例）

Consider two people with the same height:

```
[[7,1], [7,0]]
```

If we sort only by height, the order stays:

```
[[7,1], [7,0]]
```

Insert step-by-step:

1. Insert [7,1] → queue = [[7,1]]  
2. Insert [7,0] → queue = [[7,0], [7,1]]

Although this specific example “looks” correct, the insertion was **accidentally lucky**.  
Now see a stronger, failing example.

尽管上面的例子似乎没出错，但这是 **偶然正确**，并非普适；  
下面展示一个必然失败的反例。

### Stronger failing example（必然失败的例子）

```
[[5,2], [5,0], [5,1]]
```

If sorted only by height:

```
[[5,2], [5,0], [5,1]]
```

Inserting the first person:

- Insert [5,2] at index 2 → ❌ Impossible  
- The queue is empty, but this person requires **two** people ≥5 in front of them  
- This violates the problem constraints immediately

第一步就崩溃：  
队列为空，但 [5,2] 要求前面必须有 2 个身高 ≥5 的人，无法满足。

### Correct sorting order（正确的排序顺序）

To prevent these failures, identical-height people must be sorted from:

**k small → k large**

Thus we use:

```
people.sort(key=lambda x: (-x[0], x[1]))
```

This ensures:

- People with fewer constraints (small k) are placed first  
- People with larger k will not disturb earlier placements

这样保证：

- 约束更少（k 小）的人先放  
- k 大的人后放，不会破坏之前的人前面“高个子数量”的正确性

总结：  
**“身高降序 + k 升序” 是保证插入策略正确运行的唯一排序方式。**

---

## 4. Complexity Analysis（复杂度分析）
## 4. 复杂度分析

### Time Complexity（时间复杂度）

- Sorting takes `O(n log n)`  
- Inserting each person at index k takes up to `O(n)`  
- Final worst-case complexity: **O(n²)**

排序操作 `O(n log n)`，  
每次在数组中插入位置 k 可能移动元素 `O(n)`，  
总体最坏复杂度为：**O(n²)**。

### Space Complexity（空间复杂度）

- Additional space for the reconstructed queue: `O(n)`

额外用于存储结果队列的数据结构需要 `O(n)` 空间。

