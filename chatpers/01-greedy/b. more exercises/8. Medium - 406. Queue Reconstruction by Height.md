# 5. Medium – 406. Queue Reconstruction by Height

**Tags:** Greedy, Sorting, Insertion

---

## Problem Description (English)

You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the ith person of height `hi` with exactly `ki` other people in front who have a height greater than or equal to `hi`.

Reconstruct and return the queue that is represented by the input array `people`. The returned queue should be formatted as an array queue, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).

---

## 中文题意（简要）

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 正好 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
---

## Examples

**Example 1**  

Input: `people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`  
Output: `[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]`  

**Example 2**  

Input: `people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]`  
Output: `[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]`  

---

## Constraints

- `1 <= people.length <= 2000`  
- `0 <= h <= 10^6`  
- `0 <= k < people.length`

---

## Python Code

```python
from typing import List

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        # Sort by height descending; if heights are equal, by k ascending.
        people.sort(key=lambda x: (-x[0], x[1]))

        queue: List[List[int]] = []
        for h, k in people:
            # Insert the person at index k.
            queue.insert(k, [h, k])

        return queue
```

---

## Solution Explanation (English)

The book hints that this problem requires both **sorting** and **insertion** operations, and the greedy insight is the key.

### 1. Sort by height (descending), then by k (ascending)

We first sort the array as follows:

1. Higher people come first (sort by `h` in **descending** order).  
2. Among people with the same height, smaller `k` comes first (sort by `k` in **ascending** order).

After this sorting, whenever we look at some person `[h, k]`, all people who are taller than `h` have already been placed, and people with the same height will be processed in order of increasing `k`.

### 2. Insert each person at index k

We start with an empty queue and process people in sorted order.  
For each person `[h, k]`, we insert them into the current queue at index `k`.  

Why does this work?

- Since we are processing from tallest to shortest, when we insert `[h, k]`, all people already in the queue are **not shorter** than `h`.  
- Inserting at position `k` ensures that exactly `k` people in front of them are of height `>= h`.  
- When we later insert shorter people, they do not affect the counts for taller people, because `k` only cares about people with height at least `h`.

Thus the greedy strategy of "tall first, insert at position `k`" constructs a queue satisfying all constraints.

- Time complexity: sorting takes `O(n log n)`, and insertions may cost up to `O(n^2)` in the worst case.  
- Space complexity: `O(n)` for the reconstructed queue.

---

## 题解讲解（中文）

书里对这道进阶题的提示是：**需要同时用到排序和插入操作**，核心贪心是：**先安排高个子，再安排矮个子**。

### 1. 按身高降序、k 升序排序

对数组 `people` 排序：

1. 身高 `h` 按 **降序** 排序，高个子排在前面；  
2. 如果身高相同，则按 `k` **升序** 排序。  

排序后，当我们处理某个人 `[h, k]` 时，所有比他高的人都已经处理完成，同身高的人会从小 `k` 到大 `k` 依次处理。

### 2. 依次插入到下标 k 的位置

从空队列 `queue` 开始，按排序后的顺序遍历每个人 `[h, k]`，直接把他插入到 `queue` 的下标 `k` 位置：

- 因为已经排好的都是身高 `>= h` 的人，插入到位置 `k`，就保证他前面正好有 `k` 个身高不低于他的人；  
- 之后插入更矮的人时，只会在他前后插入个子更矮的人，不会改变他前面“高个子”的数量。

因此，“**按身高降序排序 + 按 k 插入**”就是满足题目条件的贪心构造方法。

时间复杂度：排序 `O(n log n)`，插入最坏 `O(n^2)`；空间复杂度 `O(n)`。

---
