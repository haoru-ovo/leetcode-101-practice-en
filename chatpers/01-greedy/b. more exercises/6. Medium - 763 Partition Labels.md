
# 3. Medium – 763. Partition Labels

**Tags:** Greedy, Hash Table, Two Pointers, String

---

## Problem Description (English)

You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string "ababcc" can be partitioned into `["abab", "cc"]`, but partitions such as `["aba", "bcc"]` or `["ab", "ab", "cc"]` are invalid.

Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.

Return a list of integers representing the size of these parts.


---

## 中文题意（简要）

你有一个字符串 `s`。
你需要把这个字符串切成尽可能多的片段（partition）。

要求是：每个字母最多只能出现在一个片段中。

也就是说：
如果某个字母 `'a'` 在第 0、5 个位置出现，那么它所在的整个区间必须保持在同一个片段里，不能被分开。

---

## Examples

**Example 1**  

Input: `s = "ababcbacadefegdehijhklij"`  
Output: `[9,7,8]`  

**Example 2**  

Input: `s = "eccbbbbdec"`  
Output: `[10]`  

---

## Constraints

- `1 <= s.length <= 500`  
- `s` consists of lowercase English letters.

---

## Python Code（My Readable Version）

```python
from typing import List, Dict
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        # Step 1: Construct a dictionary to record the last occurrence position of each character
        # For example, s = "abac", resulting in {'a':2, 'b':1, 'c':3}
        last_occurrence: Dict[str, int] = {}
        for index, char in enumerate(s):
            last_occurrence[char] = index

        # Step 2: Scan the string from left to right and use a greedy algorithm to divide it into intervals.
        result: List[int] = []
        partition_start = 0
        partition_end = 0
        for index, char in enumerate(s):
            partition_end = max(partition_end, last_occurrence[char])
            if index == partition_end:
                result.append(partition_end - partition_start + 1)
                partition_start = index + 1

        return result
```
---
# Step 1 Explanation — Last Occurrence Dictionary

## English Explanation

### 1. What is Step 1 doing?

We are building a dictionary (hash map) named `last_occurrence`:

    last_occurrence[char] = index

This table records the **last index where each character appears** in the string.

### 2. Why use a dictionary?

Because lookup and updates are O(1), and characters may repeat many times.
A dictionary ensures we always store the *final* (right-most) index for each character.

### 3. How does the loop work?

    for index, char in enumerate(s):

- `enumerate(s)` produces pairs:  
  (0,'a'), (1,'b'), (2,'a'), ...

- `index` → the current position  
- `char` → the character at that position

Inside the loop:

    last_occurrence[char] = index

Each time a character appears again, we overwrite the previous index.
Once the loop ends, the dictionary contains the **final** occurrence index.

### Example

For s = "abac":

| index | char | last_occurrence after update |
|-------|------|-----------------------------|
| 0     | a    | {'a': 0}                    |
| 1     | b    | {'a': 0, 'b': 1}            |
| 2     | a    | {'a': 2, 'b': 1}            |
| 3     | c    | {'a': 2, 'b': 1, 'c': 3}    |

Final result:

    {'a': 2, 'b': 1, 'c': 3}

---

## 中文讲解

### 1. Step 1 在做什么？

我们正在构建一个字典哈希表 `last_occurrence`：

    last_occurrence[字符] = 该字符最后一次出现的下标

这个表的作用是：快速得到每个字符在字符串中最右边出现的位置。

### 2. 为什么要用字典？

因为字典查找 / 更新都只需 O(1)，并且字符可能出现多次。
字典让我们能够 “不断覆盖旧值”，最终留下 **最后一次出现的位置**。

### 3. 循环如何工作？

    for index, char in enumerate(s):

- `enumerate(s)` 会生成 (下标, 字符) 的组合  
- `index` 是当前下标  
- `char` 是当前位置的字符

循环体：

    last_occurrence[char] = index

如果字符重复出现，后面的 index 覆盖前面的 index。

最终得到每个字符的最终位置。

### 示例

字符串 s = "abac"：

| 下标 index | 字符 char | 更新后的字典 last_occurrence |
|------------|-----------|------------------------------|
| 0          | a         | {'a': 0}                     |
| 1          | b         | {'a': 0, 'b': 1}             |
| 2          | a         | {'a': 2, 'b': 1}             |
| 3          | c         | {'a': 2, 'b': 1, 'c': 3}     |

最终结果：

    {'a': 2, 'b': 1, 'c': 3}
    
---
# Step 2 Explanation — Greedy Partitioning


## English Explanation

We keep two pointers:

- `partition_start` → the start index of the current partition  
- `partition_end` → the farthest last occurrence among all characters seen so far  

### 1. Expanding the partition boundary

    partition_end = max(partition_end, last_occurrence[char])

Meaning:

We must ensure the current segment includes **all** future occurrences of `char`.  
So `partition_end` becomes the maximum last occurrence of all seen characters.

### 2. When to cut a partition?

    if index == partition_end:

This means:

- Every character inside `[partition_start, partition_end]`
  will not appear again later.

So this window can be safely cut off.

### 3. Save partition length & move to next partition

    result.append(partition_end - partition_start + 1)
    partition_start = index + 1

This forms one partition and resets the next starting point.

---

## 中文讲解

我们维护两个指针：

- `partition_start`：当前分段的起点  
- `partition_end`：本段中所有字符 “最后一次出现的位置” 的最大值  

### 1. 扩大当前分段的边界

    partition_end = max(partition_end, last_occurrence[char])

含义：

- 本段必须覆盖字符 `char` 的最后出现位置  
- 因此需要把分段右边界扩展到所有出现过的字符的最远点

### 2. 判断是否可以切分

    if index == partition_end:

当扫描到的位置 `index` 等于分段必须覆盖的最远边界时：

- `[partition_start, partition_end]` 内所有字符都不会再出现  
- 可以安全地从这里切开一段

### 3. 保存这一段 & 开启下一段

    result.append(partition_end - partition_start + 1)
    partition_start = index + 1

记录分段长度，然后开始下一段。

---
# Why Greedy Works? / 为什么贪心正确？

## English
- Cutting earlier (`i < partition_end`) would split a character across partitions → invalid  
- Cutting later (`i > partition_end`) would only make partitions larger, reducing count → not optimal  

Therefore, cutting **exactly when `i == partition_end`** is optimal.

## 中文
- 如果在 `i < partition_end` 时切分，会把某个字符“截断”，后面还会再出现 → 不合法  
- 如果在 `i > partition_end` 时切分，只会让这一段变长、导致分段数量变少 → 不最优  

因此：  
**在 `i == partition_end` 的瞬间切分，就是唯一正确且最优的贪心策略。**

------------------------------------------------------------
# Complexity


- **Time 时间复杂度**: O(n)  
- **Space 空间复杂度**: O(1)（最多 26 个字母）
