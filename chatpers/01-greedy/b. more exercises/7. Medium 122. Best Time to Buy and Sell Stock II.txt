# 4. Medium – 122. Best Time to Buy and Sell Stock II

**Tags:** Array, Greedy, Dynamic Programming

---

## Problem Description (English)

You are given an integer array `prices` where `prices[i]` is the stock price on day `i`.

You may complete as many transactions as you like (buy one share and later sell it), subject to the following rules:

- You may not hold more than one share at a time.  
- You must sell the stock before you buy again.  
- You may buy and sell on the same day.

Return the **maximum profit** you can achieve.

---

## 中文题意（简要）

给定数组 `prices`，`prices[i]` 表示第 `i` 天的股票价格。  
你可以进行任意多次“买入 + 卖出”操作，但同一时间最多只能持有一股股票（买之前必须先卖掉上一股），允许同一天买入卖出。  
求能获得的最大利润。

---

## Examples

**Example 1**  

Input: `prices = [7,1,5,3,6,4]`  
Output: `7`  

Explanation:  
Buy at price 1, sell at price 5 (profit = 4).  
Buy at price 3, sell at price 6 (profit = 3).  
Total profit = 4 + 3 = 7.

**Example 2**  

Input: `prices = [1,2,3,4,5]`  
Output: `4`  

**Example 3**  

Input: `prices = [7,6,4,3,1]`  
Output: `0`  

---

## Constraints

- `1 <= prices.length <= 3 * 10^4`  
- `0 <= prices[i] <= 10^4`

---

## Python Code

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0

        # Greedy: take every positive difference between consecutive days.
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]

        return profit
```

---

## Solution Explanation (English)

In the book, stock problems are treated as dynamic programming and state-machine problems.  
For this particular problem, where the number of transactions is **unlimited** and there is **no transaction fee or cooldown**, the DP simplifies to a very simple greedy rule.

Observe that whenever the price goes up from day `i-1` to day `i`:

- If we bought on day `i-1` and sold on day `i`, we would gain `prices[i] - prices[i-1]` profit.  
- We are allowed to perform as many such operations as we want, provided we never hold more than one share at once.

Now look at any increasing sequence of prices, for example `[1, 3, 2, 5]`:
- One strategy is to buy at 1 and sell at 5 (profit = 4).  
- Another is to take every rise individually: `(3-1) + (5-2) = 2 + 3 = 5`.  

However, if we carefully follow the “buy low, sell high” logic with non-overlapping transactions, summing every positive increment between consecutive days yields exactly the maximum total profit that any strategy can achieve under the constraints. Intuitively, buying at every local minimum and selling at every local maximum is equivalent to summing all positive daily gains.

Therefore the algorithm is:

1. Initialize `profit = 0`.
2. For each `i` from 1 to `n - 1`:
   - If `prices[i] > prices[i-1]`, add `prices[i] - prices[i-1]` to `profit`.
3. Return `profit`.

This is exactly the “take all upward slopes” strategy.

- Time complexity: `O(n)`  
- Space complexity: `O(1)` extra space

---

## 题解讲解（中文）

在书中，股票题一般用动态规划和“状态机”来统一处理。  
但这道题比较简单：允许无限次交易，没有手续费和冷却期，因此 DP 最终可以化简成一个很直观的贪心策略：**把所有上涨的差值都赚到手**。

具体思路：

1. 如果某天的价格比前一天高，比如从 `prices[i-1]` 涨到 `prices[i]`：  
   - 可以理解为在第 `i-1` 天买入，第 `i` 天卖出，赚 `prices[i] - prices[i-1]`。  
2. 把所有“今天比昨天贵”的差值加起来，就好像我们一直在“低价买，高价卖”，并且操作不会互相冲突。  

把一段上涨区间看成整体（比如 `1 -> 3 -> 2 -> 5`）时：  
- 选择在最低价买、最高价卖得到的总利润，其实和“把所有单步上涨差值相加”的结果是一样的；  
- 所以逐日累加所有正的差值，不会比“精细挑选买卖点”更亏。

算法步骤：

1. 令 `profit = 0`；  
2. 遍历下标 `i = 1 .. n-1`：  
   - 如果 `prices[i] > prices[i-1]`，就把 `prices[i] - prices[i-1]` 加到 `profit` 里；  
3. 遍历结束后返回 `profit` 即可。  

时间复杂度 `O(n)`，空间复杂度 `O(1)`。

---
