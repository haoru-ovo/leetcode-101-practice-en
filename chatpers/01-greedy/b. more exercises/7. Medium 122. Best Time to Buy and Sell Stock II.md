# 4. Medium – 122. Best Time to Buy and Sell Stock II

**Tags:** Array, Greedy, Dynamic Programming

---

## Problem Description (English)

ou are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i` th day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.

Find and return the maximum profit you can achieve.

 

---

## 中文题意（简要）

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候**最多**只能持有**一股**股票。然而，你可以在**同一天**多次买卖该股票，但要确保你持有的股票不超过一股。

返回你能获得的**最大**利润 。
---

## Examples

**Example 1**  

Input: `prices = [7,1,5,3,6,4]`  
Output: `7`  

Explanation:  
Buy at price 1, sell at price 5 (profit = 4).  
Buy at price 3, sell at price 6 (profit = 3).  
Total profit = 4 + 3 = 7.

**Example 2**  

Input: `prices = [1,2,3,4,5]`  
Output: `4`  

**Example 3**  

Input: `prices = [7,6,4,3,1]`  
Output: `0`  

---

## Constraints

- `1 <= prices.length <= 3 * 10^4`  
- `0 <= prices[i] <= 10^4`

---

## Python Code

```python
from typing import List

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0

        # Greedy: take every positive difference between consecutive days.
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]

        return profit
```

---

## Solution Explanation (English)

In the book, stock problems are treated as dynamic programming and state-machine problems.  
For this particular problem, where the number of transactions is **unlimited** and there is **no transaction fee or cooldown**, the DP simplifies to a very simple greedy rule.

Observe that whenever the price goes up from day `i-1` to day `i`:

- If we bought on day `i-1` and sold on day `i`, we would gain `prices[i] - prices[i-1]` profit.  
- We are allowed to perform as many such operations as we want, provided we never hold more than one share at once.

Now look at any increasing sequence of prices, for example `[1, 3, 2, 5]`:
- One strategy is to buy at 1 and sell at 5 (profit = 4).  
- Another is to take every rise individually: `(3-1) + (5-2) = 2 + 3 = 5`.  

However, if we carefully follow the “buy low, sell high” logic with non-overlapping transactions, summing every positive increment between consecutive days yields exactly the maximum total profit that any strategy can achieve under the constraints. Intuitively, buying at every local minimum and selling at every local maximum is equivalent to summing all positive daily gains.

Therefore the algorithm is:

1. Initialize `profit = 0`.
2. For each `i` from 1 to `n - 1`:
   - If `prices[i] > prices[i-1]`, add `prices[i] - prices[i-1]` to `profit`.
3. Return `profit`.

This is exactly the “take all upward slopes” strategy.

- Time complexity: `O(n)`  
- Space complexity: `O(1)` extra space

---

## 题解讲解（中文）

在书中，股票题一般用动态规划和“状态机”来统一处理。  
但这道题比较简单：允许无限次交易，没有手续费和冷却期，因此 DP 最终可以化简成一个很直观的贪心策略：**把所有上涨的差值都赚到手**。

具体思路：

1. 如果某天的价格比前一天高，比如从 `prices[i-1]` 涨到 `prices[i]`：  
   - 可以理解为在第 `i-1` 天买入，第 `i` 天卖出，赚 `prices[i] - prices[i-1]`。  
2. 把所有“今天比昨天贵”的差值加起来，就好像我们一直在“低价买，高价卖”，并且操作不会互相冲突。  

把一段上涨区间看成整体（比如 `1 -> 3 -> 2 -> 5`）时：  
- 选择在最低价买、最高价卖得到的总利润，其实和“把所有单步上涨差值相加”的结果是一样的；  
- 所以逐日累加所有正的差值，不会比“精细挑选买卖点”更亏。

算法步骤：

1. 令 `profit = 0`；  
2. 遍历下标 `i = 1 .. n-1`：  
   - 如果 `prices[i] > prices[i-1]`，就把 `prices[i] - prices[i-1]` 加到 `profit` 里；  
3. 遍历结束后返回 `profit` 即可。  

时间复杂度 `O(n)`，空间复杂度 `O(1)`。

---
